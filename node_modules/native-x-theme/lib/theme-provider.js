import React, { createContext, useCallback, useContext, useEffect, useMemo, useState, } from 'react';
import { Appearance, AppState, StatusBar } from 'react-native';
export var COLOR;
(function (COLOR) {
    COLOR["PRIMARY"] = "PRIMARY";
    COLOR["SECONDARY"] = "SECONDARY";
    COLOR["TERTIARY"] = "TERTIARY";
    COLOR["ACCENT"] = "ACCENT";
    COLOR["DIVIDER"] = "DIVIDER";
    COLOR["DISABLED"] = "DISABLED";
    COLOR["INPUT"] = "INPUT";
    COLOR["SUCCESS"] = "SUCCESS";
    COLOR["ERROR"] = "ERROR";
    COLOR["WARNING"] = "WARNING";
    COLOR["TRANSPARENT"] = "TRANSPARENT";
})(COLOR || (COLOR = {}));
export var THEME;
(function (THEME) {
    THEME["LIGHT"] = "light";
    THEME["DARK"] = "dark";
})(THEME || (THEME = {}));
export var BorderSide;
(function (BorderSide) {
    BorderSide["ALL"] = "ALL";
    BorderSide["TOP"] = "TOP";
    BorderSide["RIGHT"] = "RIGHT";
    BorderSide["BOTTOM"] = "BOTTOM";
    BorderSide["LEFT"] = "LEFT";
})(BorderSide || (BorderSide = {}));
const ThemeContext = createContext({});
export function ThemeProvider({ theme, themes = {}, autoSwitchTheme = false, autoSwitchStatusBar = true, children, }) {
    const [themeName, switchTheme] = useState(theme);
    const [barStyle, setBarStyle] = useState('light-content');
    useEffect(() => {
        let subscription;
        const calculateTheme = () => {
            switchTheme(Appearance.getColorScheme() ?? THEME.DARK);
            setBarStyle(Appearance.getColorScheme() === 'dark' ? 'light-content' : 'dark-content');
        };
        if (autoSwitchTheme) {
            if (!themes.dark) {
                console.warn('A theme by name "dark" is not provided. Turning off auto theme switching!');
            }
            else if (!themes.light) {
                console.warn('A theme by name "light" is not provided. Turning off auto theme switching!');
            }
            else {
                subscription = AppState.addEventListener('change', calculateTheme);
                calculateTheme();
            }
        }
        return () => {
            if (subscription?.remove) {
                return subscription.remove();
            }
            else {
                AppState.removeEventListener('change', calculateTheme);
            }
        };
    }, [autoSwitchTheme, themes.dark, themes.light]);
    const getColor = useCallback((name, theme) => {
        if (name == undefined) {
            return undefined;
        }
        const color = themes?.[theme || themeName]?.[name];
        if (__DEV__ && !color) {
            throw new Error(`Undefined color "${name}" in the theme "${theme}"!`);
        }
        return color;
    }, [themeName, themes]);
    const getBackgroundColor = useCallback((name, theme) => {
        if (name == undefined) {
            return undefined;
        }
        return { backgroundColor: getColor(name, theme) };
    }, [getColor]);
    const getTextColor = useCallback((name, theme) => {
        if (name == undefined) {
            return undefined;
        }
        return { color: themes?.[theme || themeName]?.[name] };
    }, [themeName, themes]);
    const getBorderColor = useCallback((name, sides = BorderSide.ALL, theme) => {
        if (name == undefined) {
            return undefined;
        }
        const color = getColor(name, theme);
        if (sides.includes(BorderSide.ALL)) {
            return { borderColor: color };
        }
        if (sides.includes(BorderSide.TOP)) {
            return { borderTopColor: color };
        }
        if (sides.includes(BorderSide.RIGHT)) {
            return { borderRightColor: color };
        }
        if (sides.includes(BorderSide.BOTTOM)) {
            return { borderBottomColor: color };
        }
        if (sides.includes(BorderSide.LEFT)) {
            return { borderLeftColor: color };
        }
    }, [getColor]);
    const value = useMemo(() => {
        return {
            themes,
            themeName,
            currentTheme: themes[themeName],
            switchTheme,
            getColor,
            getBackgroundColor,
            getTextColor,
            getBorderColor,
        };
    }, [themes, themeName, getColor, getBackgroundColor, getTextColor, getBorderColor]);
    return (React.createElement(ThemeContext.Provider, { value: value },
        autoSwitchTheme && autoSwitchStatusBar && React.createElement(StatusBar, { barStyle: barStyle }),
        children));
}
export function useTheme() {
    return useContext(ThemeContext);
}
