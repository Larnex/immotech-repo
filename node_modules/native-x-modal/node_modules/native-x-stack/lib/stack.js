import { useContainerStyle } from 'native-x-theme';
import React, { memo, useMemo } from 'react';
import { View } from 'react-native';
import { styles as s } from 'tachyons-react-native';
export var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign || (HAlign = {}));
export var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["MIDDLE"] = "middle";
    VAlign["BOTTOM"] = "bottom";
})(VAlign || (VAlign = {}));
export var Overflow;
(function (Overflow) {
    Overflow["VISIBLE"] = "visible";
    Overflow["HIDDEN"] = "hidden";
})(Overflow || (Overflow = {}));
function calculateHorizontalAlignment({ hAlign, horizontal }) {
    if (hAlign === HAlign.LEFT) {
        return horizontal ? s.justifyStart : s.itemsStart;
    }
    if (hAlign === HAlign.CENTER) {
        return horizontal ? s.justifyCenter : s.itemsCenter;
    }
    if (hAlign === HAlign.RIGHT) {
        return horizontal ? s.justifyEnd : s.itemsEnd;
    }
    return null;
}
function calculateVerticalAlignment({ vAlign, horizontal }) {
    if (vAlign === VAlign.TOP) {
        return horizontal ? s.itemsStart : s.justifyStart;
    }
    if (vAlign === VAlign.MIDDLE) {
        return horizontal ? s.itemsCenter : s.justifyCenter;
    }
    if (vAlign === VAlign.BOTTOM) {
        return horizontal ? s.itemsEnd : s.justifyEnd;
    }
    return null;
}
export const Stack = memo((props) => {
    const { hAlign, vAlign, wrap = false, reverse = false, width, height, minWidth, minHeight, maxWidth, maxHeight, justifyAround, justifyBetween, children, horizontal = false, fill, zIndex, spacing, onLayout, overflow = Overflow.VISIBLE, style, } = props;
    const styles = useContainerStyle(props);
    const flexStyles = useMemo(() => {
        if (fill === undefined)
            return null;
        return { flex: fill === true ? 1 : fill, width: width ?? '100%', height: height ?? '100%' };
    }, [fill, width, height]);
    const containerStyle = useMemo(() => [
        horizontal ? s.flexRow : s.flexColumn,
        zIndex != null ? { zIndex } : undefined,
        width != null ? { width } : undefined,
        height != null ? { height } : undefined,
        minWidth != null ? { minWidth } : undefined,
        minHeight != null ? { minHeight } : undefined,
        maxWidth != null ? { maxWidth } : undefined,
        maxHeight != null ? { maxHeight } : undefined,
        overflow === Overflow.HIDDEN ? s.overflowHidden : null,
        justifyAround ? s.justifyAround : null,
        justifyBetween ? s.justifyBetween : null,
        calculateHorizontalAlignment({ hAlign, horizontal }),
        calculateVerticalAlignment({ vAlign, horizontal }),
        reverse ? [horizontal ? s.flexRowReverse : s.flexColumnReverse] : undefined,
        wrap ? s.flexWrap : null,
        flexStyles,
        ...styles,
        style,
    ].filter(i => i != null), [
        horizontal,
        zIndex,
        width,
        height,
        minWidth,
        minHeight,
        maxWidth,
        maxHeight,
        reverse,
        hAlign,
        vAlign,
        wrap,
        justifyAround,
        justifyBetween,
        overflow,
        flexStyles,
        styles,
        style,
    ]);
    if (spacing === undefined) {
        return (React.createElement(View, { style: containerStyle, onLayout: onLayout }, children));
    }
    return (React.createElement(View, { style: containerStyle, onLayout: onLayout }, React.Children.map(children, (child, index) => (React.createElement(React.Fragment, { key: index },
        index !== 0 ? React.createElement(View, { style: { padding: spacing } }) : null,
        child)))));
});
